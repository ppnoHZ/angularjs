#指令##定义方式    ```javascript    angular.module('app', [])        .directive('myDriective', function () {            return {                restrict: 'E',                template: '<a href="http://www.baidu.com"> myDirective go to baidu </a>'            }        })    ```##命名方式和使用方式    *directive的名称要用驼峰的命名方式    *前台访问则已my-directive的方式，        例如：name为myDriective，标签名称则为my-directive,             name为myDriectiveParams,标签名则为my-driective-params        属性的设置也是类似##其他属性设置    *restrict:指定angular在编译html的时候以哪种声明格式来匹配指令定义，可以指定多个。        *E(元素):<my-directive>        *A(属性):<div my-directive>   【推荐使用，兼容性好】        *C(class):<div class="my-directive">        *M(注释):<!--directive:my-directive-->    *template:指令返回的标签内容		*templateUrl:指定某个HTML作为标签模板。    *replace:如果为true 页面中则不会出现自定义的标签<my-directive>。		*scope:默认为false,可以设置为一个bool值或者一个对象，当为true的时候会从父作用域继承并创建一个新的作用域					 注意:如果一个元素上有多个指令使用了隔离作用域，其中只有一个可以生效，只有指令模板中的根元素可获得一个新的作用域。ß     *priority:设置优先级。     *transclude:默认值false,为true的时候表示用户可以自定义内容和指令模板一起，模板中使用 ng-transclude 指令来制定自定义内容的存放位置。        例如：            指令：                <div class="content" ng-transclude>                <!-- 用户自定义内容。-->                </div>##给指令传参数    为指令单独创建一个作用域，    template: "<a href="{{ myUrl }}">{{ myLinkText }} </a>"#指令详解    ##隔离作用域        将scope设置为空：scope:{},指令模板就无法访问外部作用域了。